// Copyright 2025 Sudo Sweden AB
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package bubblebabble

import (
	"crypto/rand"
	"errors"
)

var vowels = []byte("aeiouy")
var consonants = []byte("bcdfghklmnprstvzx")

//
// *BubbleBabble* takes a message digest (often generated by either
// of the MD5 or SHA-1 message digest algorithms) and creates a fingerprint
// of that digest in "bubble babble" format. Bubble babble is a method of
// representing a message digest as a string of "real" words, to make the
// fingerprint easier to remember. The "words" are not necessarily real
// words, but they look more like words than a string of hex characters.
//
// Examples:
//     (empty string) => "xexax"
//     "1234567890"   => "xesef-disof-gytuf-katof-movif-baxux"
//     "Pineapple"    => "xigak-nyryk-humil-bosek-sonax"
//
// See: http://web.mit.edu/kenta/www/one/bubblebabble/spec/jrtrjwzi/draft-huima-01.txt
//
func BubbleBabble(input string) string {
	digest := []byte(input);
	digestLen := len(digest)

	outputBuf := make([]byte, (digestLen | 1) * 3 + 2);
	inputIndex := 0
	outputIndex := 0
	seed := 1

	read := func() int {
		c := digest[inputIndex]
		inputIndex++

		return int(c)
	}

	isInputConsumed := func() bool {
		return inputIndex >= digestLen
	}

	write := func(b byte) {
		outputBuf[outputIndex] = b
		outputIndex++
	}

	write('x')
    for {
        if (isInputConsumed()) {
			write(vowels[seed % len(vowels)])
			write('x')
			write(vowels[seed / len(vowels)])

            break;
        }

		byte1 := read()
		write(vowels[(((byte1 >> 6) & 3) + seed) % len(vowels)])
		write(consonants[(byte1 >> 2) & 0b1111])
		write(vowels[((byte1 & 3) + (seed / 6)) % len(vowels)])
        if (isInputConsumed()) {
            break
        }

		byte2 := read()
		write(consonants[(byte2 >> 4) & 0b1111])
		write('-')
		write(consonants[(byte2 >> 0) & 0b1111]);

        seed = (seed * 5 + byte1 * 7 + byte2) % 36;
    }

	write('x')

    return string(outputBuf);
}

func RandomWithEntropyOfAtLeast(minimumBits int) (string, error) {
	// Round up to next byte
	if minimumBits % 8 != 0 {
		minimumBits += 8 - (minimumBits % 8)
	}
	byteCount := minimumBits / 8

	bytes := make([]byte, byteCount)
	c, err := rand.Read(bytes)
	if err != nil {
		return "", err
	}

	if c != byteCount {
		return "", errors.New("insufficient entropy")
	}

	return BubbleBabble(string(bytes)), nil
}
